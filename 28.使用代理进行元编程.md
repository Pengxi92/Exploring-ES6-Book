## 28.使用代理进行元编程

### 28.1 概览
### 28.2 编程 vs 元编程
####    28.2.1 各种元编程
### 28.3 什么是代理
####    28.3.1 函数-特定的陷阱
####    28.3.2 拦截方法的调用
####    28.3.3 可撤销代理
####    28.3.4 代理作为原型
####    28.3.5 转发拦截操作
####    28.3.6 陷阱：不是所有的对象都可以被代理透明包装
### 28.4 代理的示例
####    28.4.1 跟踪属性的访问（get, set）
####    28.4.2 关于未知属性的警告（get, set）
####    28.4.3 负数组的索引（get）
####    28.4.4 数据绑定（set）
####    28.4.5 访问一个RESTful Web 服务（方法调用）
####    28.4.6 可撤销的参看文献
####    28.4.7 在Javascript中实现DOM
####    8.4.8 其他示例
### 28.5 代理API的设计
####    28.5.1 分层：保持基础水平和元水平的分离
####    28.5.2 虚拟对象 vs 包装器
####    28.5.3 透明虚拟化和处理程序封装
####    28.5.4 元对象协议和代理陷阱
####    28.5.5 为代理强制执行不变量
### 28.6 FAQ：proxy
####    28.6.1 enumerate陷阱在哪？
####    28.6.2 影响原型链的操作
####    28.6.3 Reflect
### 28.7 参考：the proxy API
####    28.7.1 创建代理
####    28.7.2 处理程序方法
####    28.7.3 不变量的处理器方法
####    28.7.4 影响原型链的操作
####    28.7.5 Reflect
### 28.8 总结
### 28.9 延伸阅读


### 28.1 预览

代理能够拦截和自定义对对象执行的操作（例如：获取属性），他们是元编程的特征。举例：proxy表示我们正在拦截其操作的对象，handler：处理拦截的对象。target：拦截的目标对象。
```ruby
const target = {};  
const handler = {  
    get(target, propKey, receiver) {
        console.log('get ' + propKey);  
        return 123;  
    }  
};      
const proxy = new Proxy(target, handler); 
```
### 28.2 编程与元编程
什么是元编程？
在编程中分为
* 基础级别：也称为应用程序级别，代码处理用户输入。
* 元级别：代码处理基本级别代码。
基础和元级别可以是不同的语言。在以下元程序中，元编程语言是Javascript，基础编程语言是Java。
```ruby
const str = 'Hello' + '!' . repeat ( 3 ); 
console . log ( 'System.out.println("' + str + '")' );
```
基础和元级别的语言可以是同一种，以javascript为例，eval函数，这个函数的作用是接收一个字符串，执行javascript代码。
```ruby
eval('5 + 2')
7
```
其他JavaScript操作可能看起来不像元编程，但实际上，如果你仔细观察：
```ruby
// Base level
const obj = {
    hello() {
        console.log('Hello!');
    }
};

// Meta level
for (const key of Object.keys(obj)) {
    console.log(key);
}
```
该程序正在运行时检查自己的结构。这看起来不像元编程，因为编程结构和数据结构之间的分离在JavaScript中是模糊的。所有Object.*方法都可以被认为是元编程功能。
#### 28.2.1 各种元编程
反射元编程意味着程序的自我处理， Kiczales等。 [2]区分三种反射元编程：
* 内省：具有对程序结构的只读访问权限。
* 自我修改：修改程序的结构。
* 调解：重新定义某些语言操作的语义。<br>
补充：在ES6中会有三个新的API，Symbols， Reflect，Proxy服务于元编程，
* Reflect 是 通过自省（introspection）实现反射（Reflection through introspection） —— 通常用来探索非常底层的代码信息。
* Symbols 是 实现了的反射（Reflection within implementation）—— 你将 Symbols 应用到你已有的类和对象上去改变它们的行为。
* Proxy 是 通过调解（intercession）实现反射（Reflection through intercession） —— 包装对象并通过自陷（trap）来拦截对象行为。
例子如下：
例一：内省。 Object.keys()执行内省（参见前面的示例）。
例二：自我修改。 以下函数moveProperty将属性从源移动到目标。它通过括号运算符执行自我修改，以进行属性访问，赋值运算符和delete运算符。（在生产代码中，您可能会使用属性描述符来执行此任务。）
```ruby
function moveProperty(source, propertyName, target) {
    target[propertyName] = source[propertyName];
    delete source[propertyName];
}

 const obj1 = { prop: 'abc' };
 const obj2 = {};
 moveProperty(obj1, 'prop', obj2);

obj1
{}
obj2
{ prop: 'abc' }
```
ECMAScript 5不支持调解;创建代理以填补这一空白。
### 28.3 代理解释
ES6为通过proxy实现调解。工作原理如下，您可以对对象obj执行许多操作。例如：
* 获取对象obj的属性prop （ obj.prop ）
* 检查对象obj是否具有属性prop （ obj中的'prop' in obj ）
代理是特殊对象，允许您自定义其中一些操作。使用两个参数创建代理：
* handler ：对于每个操作，都有一个相应的处理程序方法 - 如果存在 - 执行该操作。这种方法拦截操作（在到达目标的途中）并被称为陷阱 （从操作系统领域借用的术语）。
* target ：如果处理程序没有拦截操作，那么它将在目标上执行。也就是说，它充当处理程序的后备。在某种程度上，代理包装目标。
```ruby
const target = {};
const handler = {
    /** Intercepts: getting properties */
    // receiver指的是Proxy的实例对象
    get(target, propKey, receiver) {
        console.log(`GET ${propKey}`);
        return 123;
    },

    /** Intercepts: checking whether properties exist */
    has(target, propKey) {
        console.log(`HAS ${propKey}`);
        return true;
    }
};
const proxy = new Proxy(target, handler);
```
当我们获取属性foo ，处理程序拦截该操作：
```ruby
proxy.foo
GET foo
123
```
同样， in运算符触发器has ：
```ruby
'hello' in proxy
HAS hello
true
```
处理程序不实现陷阱set （设置属性）。因此，设置proxy.bar会转发到target并导致设置target.bar 。
```ruby
proxy.bar = 'abc';
target.bar
'abc'
```
#### 28.3.1 函数-- 特定的陷阱
如果目标是一个函数，则可以拦截另外两个操作：
* apply ：进行函数调用，触发通过
1. proxy（···）
2. proxy.call（...）	
3. proxy.apply（...）
* construct ：进行构造函数调用，触发通过
1. new proxy（···）
仅为函数目标启用这些陷阱的原因很简单：否则，您将无法转发apply和construct操作。
#### 28.3.2 拦截方法的调用
如果你想通过代理拦截方法调用，那么有一个挑战：你可以拦截操作get （获取属性值）并且你可以拦截操作apply （调用一个函数），但是对于方法调用没有单一操作你可以拦截。那是因为方法调用被视为两个独立的操作：首先get检索函数，然后apply调用该函数。因此，您必须拦截get并返回一个拦截函数调用的函数。以下代码演示了如何完成此操作。
```ruby
function traceMethodCalls(obj) {
    const handler = {
        get(target, propKey, receiver) {
            const origMethod = target[propKey];
            return function (...args) {
                const result = origMethod.apply(this, args);
                console.log(propKey + JSON.stringify(args)
                    + ' -> ' + JSON.stringify(result));
                return result;
            };
        }
    };
    return new Proxy(obj, handler);
}
```
我没有为后一个任务使用代理，我只是用一个函数包装原始方法。
让我们使用以下对象来尝试traceMethodCalls() ：
```ruby
const obj = {
    multiply(x, y) {
        return x * y;
    },
    squared(x) {
        return this.multiply(x, x);
    },
};
```
tracedObj是obj的跟踪版本。每次方法调用后的第一行是console.log()的输出，第二行是方法调用的结果。
```ruby
const tracedObj = traceMethodCalls(obj);
tracedObj.multiply(2,7)
multiply[2,7] -> 14
14
tracedObj.squared(9)
multiply[9,9] -> 81
squared[9] -> 81
81
```
好的是，即使是在obj.squared()内部调用this.multiply() obj.squared()被跟踪。那是因为this一直在引用代理。
这不是最有效的解决方案。例如，可以缓存方法。此外，代理本身会对性能产生影响。
#### 28.3.3 可撤销的代理
ECMAScript 6允许您创建可以撤销 （关闭）的代理：
 const { proxy , revoke } = Proxy . revocable ( target , handler );
在赋值运算符（ = ）的左侧，我们使用解构来访问属性proxy并revoke Proxy.revocable()返回的对象。
在第一次调用函数revoke之后，您应用于proxy任何操作都会导致TypeError 。随后的revoke调用没有进一步的效果。
```ruby
const target = {}; // Start with an empty object
const handler = {}; // Don’t intercept anything
const {proxy, revoke} = Proxy.revocable(target, handler);

proxy.foo = 123;
console.log(proxy.foo); // 123

revoke();

console.log(proxy.foo); // TypeError: Revoked
```
#### 28.3.4 作为原型的代理
代理proto可以成为对象obj的原型。在obj中开始的一些操作可能会在proto继续。一个这样的操作是get 。
```ruby
const proto = new Proxy({}, {
    get(target, propertyKey, receiver) {
        console.log('GET '+propertyKey);
        return target[propertyKey];
    }
});

const obj = Object.create(proto);
obj.bla;

// Output:
// GET bla
```
在obj找不到属性bla ，这就是为什么搜索在proto继续并且陷阱get在那里被触发的原因。还有更多的操作会影响原型;它们列在本章末尾。
#### 28.3.5 转发拦截的操作
处理程序未实现的陷阱的操作会自动转发到目标。除转发操作外，有时还要执行某些任务。例如，拦截所有操作并记录它们但不阻止它们到达目标的处理程序：
```ruby
const handler = {
    deleteProperty(target, propKey) {
        console.log('DELETE ' + propKey);
        return delete target[propKey];
    },
    has(target, propKey) {
        console.log('HAS ' + propKey);
        return propKey in target;
    },
    // Other traps: similar
}
```
对于每个陷阱，我们首先记录操作的名称，然后通过手动执行它来转发它。ECMAScript 6具有类似模块的对象Reflect ，它有助于转发：对于每个陷阱
```ruby
handler.trap(target, arg_1, ···, arg_n)
```
Reflect有一个方法：
```ruby
Reflect.trap(target, arg_1, ···, arg_n)
```
如果我们使用Reflect ，前面的示例如下所示。
```ruby
const handler = {
    deleteProperty(target, propKey) {
        console.log('DELETE ' + propKey);
        return Reflect.deleteProperty(target, propKey);
    },
    has(target, propKey) {
        console.log('HAS ' + propKey);
        return Reflect.has(target, propKey);
    },
    // Other traps: similar
}
```
如果我们使用Reflect ，前面的示例如下所示。
```ruby
const handler = new Proxy({}, {
    get(target, trapName, receiver) {
        // Return the handler method named trapName
        return function (...args) {
            // Don’t log args[0]
            console.log(trapName.toUpperCase()+' '+args.slice(1));
            // Forward the operation
            return Reflect[trapName](...args);
        }
    }
});
```
对于每个陷阱，代理通过我们提供的get操作请求处理程序方法。也就是说，所有处理程序方法都可以通过单元方法get 。代理API的目标之一就是使这种虚拟化变得简单。
让我们使用这个基于代理的处理程序：
```ruby
const target = {};
const proxy = new Proxy(target, handler);
proxy.foo = 123;
SET foo,123,[object Object]
proxy.foo
GET foo,[object Object]
123
```
以下交互确认已将set操作正确转发到目标：
```ruby
target.foo
```
#### 28.3.6 陷阱：代理对象不能透明包装所有的对象
代理对象可以看作是对目标对象执行的操作进行拦截-代理对象包装目标对象，代理的程序处理对象（handler）就类似于代理对象的观察者或者监听者。handler(程序处理对象)通过实现相应的方法（如：get读取属性等）指定应拦截哪些操作。如果缺少某些操作的程序处理方法，则不会拦截该操作，然后转发到目标对象。
因此如果handler是一个空对象，则代理应透明的包装目标对象，但这并不总会正常工作。
原因如下：
##### 28.3.6.1 包装对象会影响this
对目标对象进行包装是如何this的？
```ruby
const target = {
    foo() {
        return {
            thisIsTarget: this === target,
            thisIsProxy: this === proxy,
        };
    }
};
const handler = {};
const proxy = new Proxy(target, handler);
```
如果直接调用target.foo(),this指向target：
```ruby
target.foo()
{ thisIsTarget: true, thisIsProxy: false }
```
如果通过代理调用proxy.foo(),this指向的是proxy
```ruby
proxy.foo()
{ thisIsTarget: false, thisIsProxy: true }
```
所以通过代理包装目标对象后，目标对象内部的this会指向Proxy代理，此外有些原生对象的内部属性，只有通过正确的this才能拿到，Proxy也无法代理这些原生对象的属性。
##### 28.3.6.2 无法透明包装对象
通常来说，代理使用空的程序处理对象包装目标对象因该是：不会改变目标对象的行为。
但是，如果目标通过不受代理控制的机制将信息与this相关联，则会出现问题：事情失败，因为根据目标是否被包装而关联不同的信息。
例如：以下类Person在WeakMap _name存储私有信息（关于此技术的更多信息在类的章节中给出）：`(查看WeakMap资料)`
```ruby
const _name = new WeakMap();
class Person {
    constructor(name) {
        _name.set(this, name);
    }
    get name() {
        return _name.get(this);
    }
}
```
Person实例不能透明地被包装：
```ruby
const jane = new Person('Jane');
jane.name
'Jane'

const proxy = new Proxy(jane, {});
proxy.name
undefined
```
jane.name与包装的proxy.name不同。以下实现没有此问题：
```ruby
lass Person2 {
    constructor(name) {
        this._name = name;
    }
    get name() {
        return this._name;
    }
}

const jane = new Person2('Jane');
console.log(jane.name); // Jane

const proxy = new Proxy(jane, {});
console.log(proxy.name); // Jane

```
##### 28.3.6.3 包转内置构造函数的实例
大多数内置构造函数的实例也有一个不被代理拦截的机制。因此，它们也不能透明地包裹。以Date实例为例：
```ruby
const target = new Date();
const handler = {};
const proxy = new Proxy(target, handler);

proxy.getDate();
// TypeError: this is not a Date object.

```
不受代理影响的机制称为内部插槽 。这些插槽是与实例关联的类似属性的存储。规范处理这些插槽，就像它们是名称在方括号中的属性一样。例如，以下方法是内部的，可以在所有对象O上调用：
```ruby
O .[[ GetPrototypeOf ]]()
```
但是，通过正常的“get”和“set”操作是不会访问到内部插槽。如果getDate()通过代理调用，它不能找到它需要在内部插槽this ，并报TypeError 。
对于Date方法， 语言规范指出 ：
>除了特别说明以外，这个 Number 的原型对象下面定义的方法不是通用的，并且把 this 的值传递给他们必须是处于以下两种情况之一，一个数字值，或者一个有着 [[NumberData]] 内部插槽从而可以被初始化为 Number 值的对象。
##### 28.3.6.4 数组可以透明地包裹
与其他内置函数相比，Arrays可以透明地包装：
```ruby
> const p = new Proxy(new Array(), {});
> p.push('a');
> p.length
1
> p.length = 0;
> p.length
0
```
Arrays可以包装的原因是，即使自定义属性访问以使length有效，Array方法也不依赖于内部插槽 - 它们是通用的。
##### 28.3.6.5解决方案
作为变通，您可以更改处理程序如何转发方法调用，并选择性地设置this为目标，而不是代理：
```ruby
const handler = {
    get(target, propKey, receiver) {
        if (propKey === 'getDate') {
            return target.getDate.bind(target);
        }
        return Reflect.get(target, propKey, receiver);
    },
};
const proxy = new Proxy(new Date('2020-12-24'), handler);
proxy.getDate(); // 24
```
这种方法的缺点是，没有任何操作，该方法执行对this经过代理。
致谢：感谢Allen Wirfs-Brock指出本节中解释的陷阱。
#### 28.4代理的用例





























