# 28.使用代理进行元编程

### 28.1 概览
#### 28.2 编程 vs 元编程
#### 28.2.1 各种元编程
### 28.3 什么是代理
#### 28.3.1 函数-特定的陷阱
#### 28.3.2 拦截方法的调用
#### 28.3.3 可撤销代理
#### 28.3.4 代理作为原型
#### 28.3.5 转发拦截操作
#### 28.3.6 陷阱：不是所有的对象都可以被代理透明包装
### 28.4 代理的示例
#### 28.4.1 跟踪属性的访问（get, set）
#### 28.4.2 未知属性的警告（get, set）
#### 28.4.3 负数组的索引（get）
#### 28.4.4 数据绑定（set）
#### 28.4.5 访问一个RESTful Web 服务（方法调用）
#### 28.4.6 可撤销的参看文献
#### 28.4.7 在Javascript中实现DOM
#### 28.4.8 其他示例
### 28.5 代理API的设计
#### 28.5.1 分层：保持基础水平和元水平的分离
#### 28.5.2 虚拟对象 vs 包装器
#### 28.5.3 透明虚拟化和处理程序封装
#### 28.5.4 元对象协议和代理陷阱
#### 28.5.5 为代理强制执行不变量
### 28.6 FAQ：proxy
#### 28.6.1 enumerate陷阱在哪？
#### 28.6.2 影响原型链的操作
#### 28.6.3 反映
### 28.7 参考：the proxy API
#### 28.7.1 创建代理
#### 28.7.2 处理程序方法
#### 28.7.3 不变量的处理器方法
#### 28.7.4 影响原型链的操作
#### 28.7.5 反思
### 28.8 总结
### 28.9 延伸阅读


### 28.1 预览

代理能够拦截和自定义对对象执行的操作（例如：获取属性），他们是元编程的特征。举例：proxy表示我们正在拦截其操作的对象，handler：处理拦截的对象。target：拦截的目标对象。
---
`
const target = {};
const handler = {
    get(target, propKey, receiver) {
        console.log('get ' + propKey);
        return 123;
    }
};
const proxy = new Proxy(target, handler);
`
### 28.2 编程与元编程
什么是元编程？
在编程中分为
* 基础级别：也称为应用程序级别，代码处理用户输入。
* 元级别：代码处理基本级别代码。
基础和元级别可以是不同的语言。在以下元程序中，元编程中是Javascript，基础编程语言是Java。
    const str = 'Hello' + '!' . repeat ( 3 ); 
    console . log ( 'System.out.println("' + str + '")' );
基础和元级别的语言可以是同一种，以javascript为例，eval函数，这个函数的作用是接收一个字符串，执行javascript代码。
    eval('5 + 2')
    7
其他JavaScript操作可能看起来不像元编程，但实际上，如果你仔细观察：
`
/ Base level
const obj = {
    hello() {
        console.log('Hello!');
    }
};

// Meta level
for (const key of Object.keys(obj)) {
    console.log(key);
}
`
该程序正在运行时检查自己的结构。这看起来不像元编程，因为编程结构和数据结构之间的分离在JavaScript中是模糊的。所有Object.*方法都可以被认为是元编程功能。
#### 28.2.1 各种元编程
反射元编程意味着程序的自我处理， Kiczales等。 [2]区分三种反射元编程：
* 内省：具有对程序结构的只读访问权限。
* 自我修改：修改程序的结构。
* 调解：重新定义某些语言操作的语义。
补充：在ES6中会有三个新的API，Symbols， Reflect，Proxy服务于元编程，
* Reflect 是 通过自省（introspection）实现反射（Reflection through introspection） —— 通常用来探索非常底层的代码信息。
* Symbols 是 实现了的反射（Reflection within implementation）—— 你将 Symbols 应用到你已有的类和对象上去改变它们的行为。
* Proxy 是 通过调解（intercession）实现反射（Reflection through intercession） —— 包裹对象并通过自陷（trap）来拦截对象行为。
例子如下：
例一：内省。 Object.keys()执行内省（参见前面的示例）。
例二：自我修改。 以下函数moveProperty将属性从源移动到目标。它通过括号运算符执行自我修改，以进行属性访问，赋值运算符和delete运算符。（在生产代码中，您可能会使用属性描述符来执行此任务。）
`
function moveProperty(source, propertyName, target) {
    target[propertyName] = source[propertyName];
    delete source[propertyName];
}

 const obj1 = { prop: 'abc' };
 const obj2 = {};
 moveProperty(obj1, 'prop', obj2);

obj1
{}
obj2
{ prop: 'abc' }
`
ECMAScript 5不支持调解;创建代理以填补这一空白。
## 28.3 代理解释
ES6为javascript带来了调解。工作原理如下，您可以对对象obj执行许多操作。例如：
* 获取对象obj的属性prop （ obj.prop ）
* 检查对象obj是否具有属性prop （ obj中的'prop' in obj ）代理是特殊对象，允许您自定义其中一些操作。使用两个参数创建代理：
* handler ：对于每个操作，都有一个相应的处理程序方法 - 如果存在 - 执行该操作。这种方法拦截操作（在到达目标的途中）并被称为陷阱 （从操作系统域借用的术语）。
* target ：如果处理程序没有拦截操作，那么它将在目标上执行。也就是说，它充当处理程序的后备。在某种程度上，代理包装目标。
`
const target = {};
const handler = {
    /** Intercepts: getting properties */
    // receiver指的是Proxy的实例对象
    get(target, propKey, receiver) {
        console.log(`GET ${propKey}`);
        return 123;
    },

    /** Intercepts: checking whether properties exist */
    has(target, propKey) {
        console.log(`HAS ${propKey}`);
        return true;
    }
};
const proxy = new Proxy(target, handler);
`
当我们获取属性foo ，处理程序拦截该操作：
`
proxy.foo
GET foo
123
`
同样， in运算符触发器has ：
`
'hello' in proxy
HAS hello
true
`
处理程序不实现陷阱set （设置属性）。因此，设置proxy.bar会转发到target并导致设置target.bar 。
`
proxy.bar = 'abc';
target.bar
'abc'
`
### 28.3.1 函数-- 特定的陷阱
如果目标是一个函数，则可以拦截另外两个操作：
* apply ：进行函数调用，触发通过
1. proxy（···）
2. proxy.call（...）	
3. proxy.apply（...）
* construct ：进行构造函数调用，触发通过
1. new proxy（···）
仅为函数目标启用这些陷阱的原因很简单：否则，您将无法转发apply和construct操作。
### 28.3.2 拦截方法的调用
如果你想通过代理拦截方法调用，那么有一个挑战：你可以拦截操作get （获取属性值）并且你可以拦截操作apply （调用一个函数），但是对于方法调用没有单一操作你可以拦截。那是因为方法调用被视为两个独立的操作：首先get检索函数，然后apply调用该函数。因此，您必须拦截get并返回一个拦截函数调用的函数。以下代码演示了如何完成此操作。
`
function traceMethodCalls(obj) {
    const handler = {
        get(target, propKey, receiver) {
            const origMethod = target[propKey];
            return function (...args) {
                const result = origMethod.apply(this, args);
                console.log(propKey + JSON.stringify(args)
                    + ' -> ' + JSON.stringify(result));
                return result;
            };
        }
    };
    return new Proxy(obj, handler);
}
`
我没有为后一个任务使用代理，我只是用一个函数包装原始方法。
让我们使用以下对象来尝试traceMethodCalls() ：
`
const obj = {
    multiply(x, y) {
        return x * y;
    },
    squared(x) {
        return this.multiply(x, x);
    },
};
`
tracedObj是obj的跟踪版本。每次方法调用后的第一行是console.log()的输出，第二行是方法调用的结果。
`
const tracedObj = traceMethodCalls(obj);
tracedObj.multiply(2,7)
multiply[2,7] -> 14
14
tracedObj.squared(9)
multiply[9,9] -> 81
squared[9] -> 81
81
`
好的是，即使是在obj.squared()内部调用this.multiply() obj.squared()被跟踪。那是因为this一直在引用代理。
这不是最有效的解决方案。例如，可以缓存方法。此外，代理本身会对性能产生影响。
### 28.3.3 可撤销的代理
ECMAScript 6允许您创建可以撤销 （关闭）的代理：
 const { proxy , revoke } = Proxy . revocable ( target , handler );
在赋值运算符（ = ）的左侧，我们使用解构来访问属性proxy并revoke Proxy.revocable()返回的对象。
在第一次调用函数revoke之后，您应用于proxy任何操作都会导致TypeError 。随后的revoke调用没有进一步的效果。
`
const target = {}; // Start with an empty object
const handler = {}; // Don’t intercept anything
const {proxy, revoke} = Proxy.revocable(target, handler);

proxy.foo = 123;
console.log(proxy.foo); // 123

revoke();

console.log(proxy.foo); // TypeError: Revoked
`
### 28.3.4 作为原型的代理
代理proto可以成为对象obj的原型。在obj中开始的一些操作可能会在proto继续。一个这样的操作是get 。
`
const proto = new Proxy({}, {
    get(target, propertyKey, receiver) {
        console.log('GET '+propertyKey);
        return target[propertyKey];
    }
});

const obj = Object.create(proto);
obj.bla;

// Output:
// GET bla
`
在obj找不到属性bla ，这就是为什么搜索在proto继续并且陷阱get在那里被触发的原因。还有更多的操作会影响原型;它们列在本章末尾。
### 28.3.5 转发拦截的操作
处理程序未实现的陷阱的操作会自动转发到目标。除转发操作外，有时还要执行某些任务。例如，拦截所有操作并记录它们但不阻止它们到达目标的处理程序：
`
const handler = {
    deleteProperty(target, propKey) {
        console.log('DELETE ' + propKey);
        return delete target[propKey];
    },
    has(target, propKey) {
        console.log('HAS ' + propKey);
        return propKey in target;
    },
    // Other traps: similar
}
`
对于每个陷阱，我们首先记录操作的名称，然后通过手动执行它来转发它。ECMAScript 6具有类似模块的对象Reflect ，它有助于转发：对于每个陷阱
`
handler.trap(target, arg_1, ···, arg_n)
`
Reflect有一个方法：
`
Reflect.trap(target, arg_1, ···, arg_n)
`
如果我们使用Reflect ，前面的示例如下所示。
`
const handler = {
    deleteProperty(target, propKey) {
        console.log('DELETE ' + propKey);
        return Reflect.deleteProperty(target, propKey);
    },
    has(target, propKey) {
        console.log('HAS ' + propKey);
        return Reflect.has(target, propKey);
    },
    // Other traps: similar
}
`
如果我们使用Reflect ，前面的示例如下所示。
`
const handler = new Proxy({}, {
    get(target, trapName, receiver) {
        // Return the handler method named trapName
        return function (...args) {
            // Don’t log args[0]
            console.log(trapName.toUpperCase()+' '+args.slice(1));
            // Forward the operation
            return Reflect[trapName](...args);
        }
    }
});
`
对于每个陷阱，代理通过我们提供的get操作请求处理程序方法。也就是说，所有处理程序方法都可以通过单元方法get 。代理API的目标之一就是使这种虚拟化变得简单。
让我们使用这个基于代理的处理程序：
`
const target = {};
const proxy = new Proxy(target, handler);
proxy.foo = 123;
SET foo,123,[object Object]
proxy.foo
GET foo,[object Object]
123
`
以下交互确认已将set操作正确转发到目标：
`
target.foo
`
### 28.3.6 陷阱：代理人不能透明包裹所有的对象





















